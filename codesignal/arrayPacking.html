<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
/*
You are given an array of up to four non-negative integers, each less than 256.

Your task is to pack these integers into one number M in the following way:

The first element of the array occupies the first 8 bits of M;
The second element occupies next 8 bits, and so on.
Return the obtained integer M.

Note: the phrase "first bits of M" refers to the least significant bits of M - the right-most bits of an integer. For further clarification see the following example.

Example

For a = [24, 85, 0], the output should be
arrayPacking(a) = 21784.

An array [24, 85, 0] looks like [00011000, 01010101, 00000000] in binary.
After packing these into one number we get 00000000 01010101 00011000 (spaces are placed for convenience), which equals to 21784.
*/
    function arrayPacking(a) {
        const binaries = a.map(x => "00000000".substr(x.toString(2).length)
          + x.toString(2))
          .reverse()
          .join('');
        return parseInt(binaries, 2)
      }
/* Notes:
map over 'a', an array of integers, in order to convert them all into their binary form
the exercise shows that each binary number should be 8 digits long, so
I use a trick that takes a subStr of "00000000", the length of the integer in binary form,
and concatenates it with the integer itself.
subStr's first argument is the index at which to start extracting from, and 2nd optional argument
is when to end.  So by just putting in where to start, it goes til the end.
so if integer = 37, its binary is 100101, which is a length of 6.
"00000000".subStr(6) === "00" since it starts at index 6, and goes to the end.
"00" + 100101 = "00100101" due to type coercion.

Reverse the array because the first number in the array is actually the farthest right section
in the binary number.

join the array so its one long string.

parseInt(result , 2) in order to convert the long binary number into a integer.
radix of 2 is what turns it into binary.
*/

/* top solution:
No clue whats going on here.
I recognize 256 as a bit integer, and all I can think is that it's somehow being used
to evaluate each integer in 'a' as a binary number?
function arrayPacking(a) {
    return a.reduce((value, byte, i) => value + byte * Math.pow(256, i));
}
*/
  </script>
</body>
</html>
